<div ng-controller="ModelCtrl">
    <h1>Welcome to forms-angular</h1>
    <div class="row-fluid">
    <div class="hero-unit span6 big-box">
    <h4>Turn this...</h4>
    <pre>var ASchema = new Schema({
    surname: {type:String, required:true, index:true},
    forename: {type:String, index:true},
    weight: Number,
    eyeColour: {type: String, required:true,
        enum:['Blue','Brown','Green','Hazel']},
    dateOfBirth: Date,
    accepted: Boolean
});</pre>
    </div>
    <div class="hero-unit span6 big-box">
        <h4>...into this</h4>
        <img src="/img/screen.png" alt="Screen shot of simple form">
    </div>
    </div>
<h4 class="text-center">...without a line of code!</h4><br />

    <p>Forms-angular is a form builder build on top of the <a href="http://blog.mongodb.org/post/49262866911/the-mean-stack-mongodb-expressjs-angularjs-and">MEAN stack</a>
    (with a little <a href="http://twitter.github.io/bootstrap/">Twitter Bootstrap</a> and <a href="http://mongoosejs.com/">Mongoose</a> thrown in for good measure) that
    enables you to generate forms super quickly.  At its simplest it takes a mongoose schema and <em>with no effort on your part</em> generates a form, complete with REST routing and bindings.</p>


    <h3>Forms</h3>

    <p>All the input forms in the demo application use a very simple one line view:</p>
    <pre>&ltform-input ng-repeat="field in formSchema" info="{{field}}"&gt&lt/form-input&gt</pre>
    <p>which generates the forms on the client using the Mongoose schemas, optionally fine-tuned by hand.</p>

    <p>This demo application uses the models in the table below. Have a look at a schema or two and then click on the
        new
        link to see the forms that are generated by them.
    </p>
    <table class="table table-striped table-condensed">
        <tr ng-repeat="model in models | orderBy:'resource_name'">
            <td>{{model.resource_name | titleCase}}</td>
            <td><a href="/code/{{model.resource_name}}.js">View schema</a></td>
            <td><a href="/#/{{model.resource_name}}/new">New</a></td>
            <td><a href="/#/{{model.resource_name}}">List</a></td>
        </tr>
    </table>
    <p>For those who want to see the gory detail the
        <a href="/js/directives/form.js">forms</a> and the <a href="/js/directives/form-buttons.js">buttons</a> are
        generated by directives and the schema processing / behaviour is handled by a <a href="/js/controllers/base.js">controller</a>.
        The library currently weighs in at 17.3Kb minimised (obviously the ui dependencies and angular itself add
        substantially to that).</p>

    <p>For each model the following routes are supported:</p>

    <ul>
        <li><strong>/#/:model</strong> which lists the documents in the collection, with links to the form for editing
            them
        </li>
        <li><strong>/#/:model/new</strong> which enables the user to create a new document using the default form for
            the collection
        </li>
        <li><strong>/#/:model/:id/edit</strong> which enables the user to edit a document</li>
    </ul>

    <h3>Custom Form Schemas</h3>

    <p>It is easy to create custom form schemas which are a subset of the whole schema by specifying the fields
        to include and any options. See the static in <a href="/code/b_using_options.js">this example</a>.
        The custom form schemas are invoked as follows:
    </p>
    <ul>
        <li><strong>/#/:model/:formschema</strong> (<a href="/#/b_using_options/justnameandpostcode/">example here</a>)
        </li>
        <li><strong>/#/:model/:formschema/new</strong> (<a href="/#/b_using_options/justnameandpostcode/new">example
            here</a>)
        </li>
        <li><strong>/#/:model/:formschema/:id/edit</strong></li>
    </ul>

    <h3>Schema Options</h3>

    <p>The mark-up of generated forms can be influenced by use of the <strong>form</strong> object in the schema type.
        The form object can have the following keys:
        <ul>
            <li><strong>hidden      </strong></li> inhibits this schema key from the generated form.
            <li><strong>label       </strong></li> overrides the default input label.  label:null suppresses the label altogether.
            <li><strong>placeHolder </strong></li> adds placeholder text to the input (depending on data type).
            <li><strong>help        </strong></li> adds help text under the input
            <li><strong>helpInline  </strong></li> adds help to the right of the input
            <li><strong>directive   </strong></li> allows you to specify custom behaviour
            <li><strong>select2     </strong></li> in an enum field or a reference field tells the system to use the select2
                control rather than a select.  If the number of options is large in a reference field
                then <strong>select2:{fngAjax:true}</strong> instructs the program to use ajax calls to query
                the server rather than downloading the table.  The values in the select[2] control come from the <a href="/#/index#listing">listing fields</a>.
            <strong><li>rows        </strong></li> sets the number of rows in inputs (such as textarea) that support this.
        </ul>

        <a href="/code/b_using_options.js">This example schema</a> and <a href="/#/b_using_options/new">this form</a> show many of these options in use.
    </p>

    <h3 id="listing">Listing</h3>

    <p>The listing routes (of the format <strong>/#/:model</strong>) are used to build a page
        containing a list of documents in the collection, showing the fields that have a truthy <strong>list</strong>
        key.  If none of the schema objects have a list key the first two string fields are used.
    </p>

    <p>Listing routes support filters, such as</p>

    <a href="/#/b_using_options?f=%7B%22surname%22:%22Smith%22%7D">
        <pre>/#/b_using_options?f={"surname":"Smith"}</pre>
    </a>

    <p>and calls to the aggregation framework, provided they project to an array of docs that contains an _id property
        which is used
        to select from the model. For example the (rather unpalatable)</p>
    <a href="/#/f_nested_schema?a=%5B%7B%22%24unwind%22%3A%22%24exams%22%7D%2C%7B%22%24sort%22%3A%7B%22exams.score%22%3A1%7D%7D%2C%7B%22%24group%22%3A%7B%22_id%22%3A%7B%22id%22%3A%22%24_id%22%7D%2C%22bestSubject%22%3A%7B%22%24last%22%3A%22%24exams.subject%22%7D%7D%7D%2C%7B%22%24match%22%3A%7B%22bestSubject%22%3A%22English%22%7D%7D%2C%7B%22%24project%22%3A%7B%22_id%22%3A%22%24_id.id%22%7D%7D%5D">
        <pre>/#/f_nested_schema?a=[{"$unwind":"$exams"},{"$sort":{"exams.score":1}},{"$group":{"_id":{"id":"$_id"},"bestSubject":{"$last":"$exams.subject"}}},{"$match":{"bestSubject":"English"}},{"$project":{"_id":"$_id.id"}}]</pre>
    </a>

    <p>selects all students who did better in their English exam than any other subject. To find out how to use the
        aggregation framework refer to the <a href="http://docs.mongodb.org/manual/core/aggregation/">MongoDB docs</a>.
    </p>

    <p>These can be combined (though there appears to be a problem unless the filter precedes the aggregation).</p>

    <p>By default the list order is the MongoDB natural order.  The default list order for a table can be set by
        specifying a <strong>listOrder</strong> option in the model definition (see <a href="/code/g_conditional_fields.js">g_conditional_fields</a> for an example).</p>

    <h3>API</h3>

    <p>The Angular controllers make use of the following API calls:</p>

    <ul>
        <li><strong>/api/models</strong> returns an array of all the models that are available to forms-angular</li>
        <li><strong>/api/schema/:model</strong> returns the schema for a model</li>
        <li><strong>/api/schema/:model/:customForm</strong> returns the schema for a model</li>
        <li><strong>/api/:model</strong> returns an array of all the documents in a model (needs pagination)</li>
        <li><strong>/api/:model/:id</strong> returns a single document from the collection</li>
        <li><strong>/api/:model/:id/list</strong> returns how a document should appear in a list</li>
    </ul>

    <h3>Form Buttons</h3>
    The form button customisation is currently limited to over-riding the default enabled state of the buttons by
    defining
    functions in a controller for the model (or model and form). See <a href="/demo/d-array-example.js">here</a> for an
    example.
    <h3>Search</h3>

    <p>It is easy to incorporate a simple search form, as shown in the Navbar. When you enter text into it the
        SearchCtrl controller makes a call to the server which looks for matching data by searching the indexed
        fields in each model for values starting with the search string.
        There are other search API calls as shown below:</p>
    <ul>
        <li><strong>/api/search?q=string</strong> returns documents where the string is found at the beginning of an
            indexed field
        </li>
        <li><strong>/api/search/:model?q=string</strong> returns documents in the specified collection where the string
            is found at the beginning of an indexed field. Note that the search is case insensitive, so will be
            inefficient (and to be avoided on large datasets) until Mongo 2.5 comes out. (See issue <a
                    href="https://jira.mongodb.org/browse/SERVER-90" target="_blank">here</a>)
        </li>
        <li><strong>/api/search?q=string&f={<span><em>filterjson</em></span>}</strong> returns documents where the
            string is found at the beginning of an indexed field which satisfy the conditions in the filter.
        </li>
    </ul>
    <p>There are a number of options that can be added to model exports to modify the search behaviour.  Examples can be found
    in the model definitions files for <a href="/code/f_nested_schema.js">f_nested_schema</a> and <a href="/code/g_conditional_fields.js">g_conditional_fields</a>.</p>
    <ul>
        <li><strong>searchImportance</strong> can be used to determine the order of table searches.  There is an example</li>
        <li><strong>searchOrder</strong> can be used to set the default ordering of the search results within a model.
            It is normally used in conjunction with searchImportance.</li>
        <li><strong>searchResultFormat</strong> allows fine control of the display of search results.  It points to a
        function which returns an object which must contain the following:
        <ul>
            <li><strong>resource</strong> the model name (or model/customForm) that the search result will link to</li>
            <li><strong>resourceText</strong> the display name for the resource</li>
            <li><strong>id</strong> the id to link to</li>
            <li><strong>weighting</strong> specifies the sort ordering</li>
            <li><strong>text</strong> the display text for the item</li>
        </ul></li>
    </ul>

    A truthy <strong>noSearch</strong> key means index on a schema type is not used in the searchBox searches.
    A use case for this would be an index that is used in reports for grouping which has no meaning in a search.

    <h3>Navigation</h3>

    <p>The menu can be added to where required by the models. The NavCtrl controller loads menus from "model
        controllers"
        (see an example <a href="/#/b_using_options">here</a> and the controller source code <a
                href="/demo/b-using-options.js">here</a>).
        The options can be configured to appear when records are being listed, edited or created.</p>
</div>